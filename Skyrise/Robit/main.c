#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ATN,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  AQE,            sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  statusLED,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  FRD,            sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  BRD,            sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  BLD,            sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  FLD,            sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  E,              sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           FRD,           tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           BRD,           tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           FLD,           tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port5,           BLD,           tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           E,             tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           AR,            tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port8,           AL,            tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Platform
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#pragma systemFile	// eliminates warning for "unreferenced" functions

//Includes
#include "Vex_Competition_Includes.c"   //Main competition background code
#include "libraries\smartMotorLib.c"	//Jpearman's Smart Motor Library
#include "functions.h"	//Functions

// Pre-Autonomous //
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false;
	// Initialize the Smart Motor Library
	SmartMotorsInit();
	// Arm motors and extender motor on power extender
	SmartMotorsAddPowerExtender( AR, AL, E );
	// one encoder for all arm motors
	SmartMotorLinkMotors( AR, AL );
	// Limit current based on default motor current threshold
	SmartMotorCurrentMonitorEnable();
	// Limit current in the motors using PTC temperatures
	SmartMotorPtcMonitorEnable();
	// led to monitor the power expander
	SmartMotorSetControllerStatusLed( SMLIB_PWREXP_PORT_0, statusLED );
	// Run smart motors
	SmartMotorRun();
}

// Autonomous Mode //
task autonomous()
{
	// in case we were running
	stopTask( usercontrol );

	if(SensorValue[ATN] <= 100)
	{
		liftUp(120);
		liftDown(90);
		forward(300);
		extendExtension(2600);
	}
	else if (SensorValue(ATN) >300 && (SensorValue(ATN) <=800))
	{
		//Autonomous 2 Placeholder
	}
	else if (SensorValue(ATN) >1000 && (SensorValue(ATN) <=1500))
	{
		//Autonomous 3 Placeholder
	}
	else if (SensorValue(ATN) >1700 && (SensorValue(ATN) <=2200))
	{
		//Autonomous 4 Placeholder
	}
	else if (SensorValue(ATN) >2340 && (SensorValue(ATN) <=2925))
	{
		//Autonomous 5 Placeholder
	}
	else if (SensorValue(ATN) >2925 && (SensorValue(ATN) <=3510))
	{
		//Autonomous 6 Placeholder
	}
	else if (SensorValue(ATN) >3510 && (SensorValue(ATN) <=4095))
	{
		//Autonomous 7 Placeholder
	}
}

// Tele-op //
task usercontrol()
{
	//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

	short arm;
	short extender;
	long FrontRight, FrontLeft, BackRight, BackLeft;

	// in case we were running
	stopTask( autonomous );

	//Loop Forever
	while(1)
	{
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold)
			Y1 = vexRT[Ch3];
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold)
			X1 = vexRT[Ch4];
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold)
			X2 = vexRT[Ch1];
		else
			X2 = 0;

		//Remote Control Commands
		FrontRight = Y1 - X2 - X1;
		BackRight =  Y1 - X2 + X1;
		FrontLeft = Y1 + X2 + X1;
		BackLeft =  Y1 + X2 - X1;

		SetMotor( FRD, FrontRight, 100);
		SetMotor( BRD, BackRight, 100);
		SetMotor( FLD, FrontLeft, 100);
		SetMotor( BLD, BackLeft, 100);

		//Arm
		if( vexRT[ Btn6U ] )
			arm = 127;
		else
			if( vexRT[ Btn6D ] )
			arm = -127;
		else
			arm = 0;

		SetMotor( AR, arm, 127 );
		SetMotor( AL, arm, 127 );

		//Intake
		if( vexRT[ Btn5U ] )
			extender = 127;
		else
			if( vexRT[ Btn5D ] )
			extender = -127;
		else
			extender = 0;

		SetMotor( E, extender, 127 );

		wait1Msec(25);
	}
}
