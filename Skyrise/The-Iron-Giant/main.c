#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    Potent,         sensorPotentiometer)
#pragma config(Sensor, dgtl3,  RLQ,            sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           BRD,           tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           FRD,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           FLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           BLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           RL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RB,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LB,            tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Platform
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Libraries
#include "Vex_Competition_Includes.c"
#include "Functions.h"

//Pre-Autonomous//
void pre_auton()
{
	nMotorEncoder[BRD] = 0;
	nMotorEncoder[LB] = 0;
	SensorValue[RLQ] = 0;
}

// Autonomous Mode //
task autonomous()
{
	// in case we were running
	stopTask( usercontrol );

	if(SensorValue[Potent] <= 100)
	{
		//2 Cube Mid Post RED
		intake(5);
		forwardd(100);
		intake(600);
		strafeleft(450);
		wait1Msec(300);
		forwardd(130);
		wait1Msec(300);
		turnright(338);
		liftup(73);
		forwardd(280);
		wait1Msec(550);
		outtake(1275);
		backward(100);
		liftdown(56);
		turnleft(950);
	}

	else if (SensorValue(Potent) >300 && (SensorValue(Potent) <=800))
	{
		//2 Cube Mid Post BLU
		intake(5);
		forwardd(100);
		intake(600);
		straferight(350);
		wait1Msec(300);
		forwardd(130);
		wait1Msec(300);
		turnleft(495);
		liftup(73);
		forwardd(248);
		wait1Msec(550);
		outtake(1375);
		backward(100);
		liftdown(56);
		turnright(900);
	}

	else if (SensorValue(Potent) >1000 && (SensorValue(Potent) <=1500))
	{
		//Autonomous 3 Placeholder
	}

	else if (SensorValue(Potent) >1700 && (SensorValue(Potent) <=2200))
	{
		//Autonomous 4 Placeholder
	}

	else if (SensorValue(Potent) >2340 && (SensorValue(Potent) <=2925))
	{
		//Autonomous 5 Placeholder
	}

	else if (SensorValue(Potent) >2925 && (SensorValue(Potent) <=3510))
	{
		//Autonomous 6 Placeholder
	}

	else if (SensorValue(Potent) >3510 && (SensorValue(Potent) <=4095))
	{
		//Autonomous 7 Placeholder
	}
}

//User Control//
task usercontrol()
{
	//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;
	int count = 0;

	while (true)
	{
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold)
			Y1 = vexRT[Ch3];
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold)
			X1 = vexRT[Ch4];
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold)
			X2 = vexRT[Ch1];
		else
			X2 = 0;

		//Remote Control Commands
		motor[FRD] = Y1 - X2 - X1;
		motor[BRD] =  Y1 - X2 + X1;
		motor[FLD] = Y1 + X2 + X1;
		motor[BLD] =  Y1 + X2 - X1;

		//Belt
		if(vexRT[Btn5U] == 1)
		{
			motor[LB] = 127;
			motor[RB] = 127;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[LB] = -127;
			motor[RB] = -127;
		}
		else
		{
			motor[LB] = 0;
			motor[RB] = 0;
		}

		//Lift control
		if(vexRT[Btn6U] == 1)
		{
			motor[RL] = 127;
			motor[LL] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[RL] = -127;
			motor[LL] = -127;
		}
		else
		{
			motor[RL] = 0;
			motor[LL] = 0;
		}

		//Everything Toggle
		switch(count){
		case 0:
			//Change "count" based on button press
			if(vexRT[Btn8D] == 1)
			{
				count = 1;
			}
			break;
		case 1:
			//Change "count" based on button press
			motor[LL] = 25;
			motor[RL] = 25;
			if(vexRT[Btn8U] == 1)
			{
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
}
